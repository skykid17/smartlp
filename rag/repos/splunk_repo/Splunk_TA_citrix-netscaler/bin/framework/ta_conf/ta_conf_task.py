#
# SPDX-FileCopyrightText: 2024 Splunk, Inc.
# SPDX-License-Identifier: LicenseRef-Splunk-8-2021
#
#

import logging
import os
import os.path as op

from solnlib import conf_manager, credentials
from splunk.clilib import cli_common as cli
from splunktaucclib.rest_handler.credentials import RestCredentials as RC
from ta_util2 import utils

_LOGGER = logging.getLogger("ta_app_conf")

ENCRYPTED_MAGIC_TOKEN = RC.PASSWORD


class TAConfTask:
    """
    Responsibilities:
    1) Monitor confs which are generated by Web
    2) Generate tasks
    """

    def __init__(
        self, meta_configs, server_file, template_file, task_file, global_file
    ):
        """
        @meta_configs: dict contains Splunk server_uri, checkpoint_dir and
                       session_key
        """

        self.metas = meta_configs
        self.server_file = server_file
        self.template_file = template_file
        self.task_file = task_file
        self.global_file = global_file

    def encrypt_credentials(self):
        # Get splunk_home path
        splunk_home = os.environ["SPLUNK_HOME"]
        app_name = self.metas["app_name"]
        server_file_path = os.path.join(
            splunk_home, "etc", "apps", app_name, "local", self.server_file
        )

        if op.isfile(server_file_path):

            server_config = cli.readConfFile(server_file_path)
            server_config.pop("default")

            conf_mgr = conf_manager.ConfManager(
                self.metas["session_key"],
                self.metas["app_name"],
                realm="__REST_CREDENTIAL__#{}#configs/conf-citrix_netscaler_servers".format(
                    self.metas["app_name"]
                ),
            )

            # Check if citrix_netscaler_servers.conf exists and exit if not found
            try:
                server_conf = conf_mgr.get_conf(
                    self.server_file.replace(".conf", ""), refresh=True
                )
            except conf_manager.ConfManagerException:
                _LOGGER.debug(
                    "Config file: {} not found. So, exiting modular input.".format(
                        self.server_file
                    )
                )
                return
            server_conf.reload()
            # Get values from citrix_netscaler_servers.conf and exit if credentials do not exist
            try:
                servers = server_conf.get_all()
            except credentials.CredentialNotExistException:
                raise Exception(
                    "It looks like there has been unexpected modification in: {} file from backend, "
                    "Data collection for all inputs have been stopped. Please reload the configuration page "
                    "from UI or restart Splunk. Exiting..".format(self.server_file)
                )

            # Encrypt citrix appliance's username and password if not encrypted
            for server in server_config:
                server_info = server_config[server]
                # Get values of appliance username and appliance password using conf manager
                if (
                    server_info.get("account_name") is None
                    and server_info.get("account_password") is None
                ) or (
                    server_info.get("account_name") == ""
                    and server_info.get("account_password") == ""
                ):
                    continue

                for server_stanza, server_info_conf in list(servers.items()):
                    if server_stanza == server:
                        if server_info.get("account_name") is None:
                            server_info["account_name"] = ""
                            server_info_conf["account_name"] = ""
                        if server_info.get("account_password") is None:
                            server_info["account_password"] = ""
                            server_info_conf["account_password"] = ""

                        server_stanza_user = server_info_conf["account_name"]
                        server_stanza_password = server_info_conf["account_password"]

                # Check if both appliance username and appliance password are in clear text and encrypt
                if (
                    server_info["account_name"] != ENCRYPTED_MAGIC_TOKEN
                    and server_info["account_password"] != ENCRYPTED_MAGIC_TOKEN
                ):
                    _LOGGER.info(
                        "Encrypting clear username and password for server=%s",
                        server_info["server_url"],
                    )
                    server_conf.update(
                        server,
                        {
                            "account_name": server_info["account_name"],
                            "account_password": server_info["account_password"],
                        },
                        ["account_name", "account_password"],
                    )
                # Check if only appliance username is in clear text and encrypt accordingly
                elif not server_info["account_name"] == ENCRYPTED_MAGIC_TOKEN:
                    _LOGGER.info(
                        "Encrypting clear username for server=%s",
                        server_info["server_url"],
                    )
                    server_conf.update(
                        server,
                        {
                            "account_name": server_info["account_name"],
                            "account_password": server_stanza_password,
                        },
                        ["account_name", "account_password"],
                    )
                # Check if only appliance password is in clear text and encrypt accordingly
                elif not server_info["account_password"] == ENCRYPTED_MAGIC_TOKEN:
                    _LOGGER.info(
                        "Encrypting clear password for server=%s",
                        server_info["server_url"],
                    )
                    server_conf.update(
                        server,
                        {
                            "account_name": server_stanza_user,
                            "account_password": server_info["account_password"],
                        },
                        ["account_name", "account_password"],
                    )

        global_file_path = os.path.join(
            splunk_home, "etc", "apps", app_name, "local", self.global_file
        )

        if op.isfile(global_file_path):
            global_config = cli.readConfFile(global_file_path)
            global_config.pop("default")

            conf_mgr_global = conf_manager.ConfManager(
                self.metas["session_key"],
                self.metas["app_name"],
                realm="__REST_CREDENTIAL__#{}#configs/conf-splunk_ta_citrix_netscaler_settings".format(
                    self.metas["app_name"]
                ),
            )

            # Check if splunk_ta_citrix_netscaler_settings.conf exists and exit if not found
            try:
                global_conf = conf_mgr_global.get_conf(
                    self.global_file.replace(".conf", ""), refresh=True
                )
            except conf_manager.ConfManagerException:
                _LOGGER.debug(
                    "Config file: {} not found. So, exiting modular input.".format(
                        self.global_file
                    )
                )
                return

            # Encrypt proxy password if not encrypted
            for stanza in global_config:
                if stanza == "proxy":
                    proxy_info = global_config[stanza]
                    proxy_password = proxy_info.get("proxy_password")
                    if (
                        proxy_password != None  # noqa: E711
                        and proxy_password != ""
                        and proxy_password != ENCRYPTED_MAGIC_TOKEN
                    ):
                        _LOGGER.info(
                            "Encrypting clear password for proxy_server=%s",
                            proxy_info["proxy_url"],
                        )
                        global_conf.update(
                            stanza,
                            {"proxy_password": proxy_password},
                            ["proxy_password"],
                        )
                    break

    def get_tasks(self, inputs):

        conf_files = [self.server_file, self.template_file]
        conf_mgr = conf_manager.ConfManager(
            self.metas["session_key"],
            self.metas["app_name"],
            realm="__REST_CREDENTIAL__#{}#configs/conf-citrix_netscaler_servers".format(
                self.metas["app_name"]
            ),
        )
        conf_objs = []
        for conf_file in conf_files:
            conf_objs.append(self._get_conf_objects(conf_mgr, conf_file))

        global_conf_file = self.global_file
        conf_mgr_global = conf_manager.ConfManager(
            self.metas["session_key"],
            self.metas["app_name"],
            realm="__REST_CREDENTIAL__#{}#configs/conf-splunk_ta_citrix_netscaler_settings".format(
                self.metas["app_name"]
            ),
        )
        conf_objs.append(self._get_conf_objects(conf_mgr_global, global_conf_file))

        conf_objs.append(self._get_input_task_objects(inputs))

        for server, server_info in conf_objs[0].items():
            if not server_info.get("account_name"):
                conf_objs[0][server]["account_name"] = ""
            if not server_info.get("account_password"):
                conf_objs[0][server]["account_password"] = ""

        all_task_configs = []
        for _, task in conf_objs[3].items():
            task_configs = self._get_server_and_task_template_info_for_task(
                task, conf_objs[0], conf_objs[1]
            )
            all_task_configs.extend(task_configs)

        log_level = "INFO"
        http_scheme = "https"
        disable_ssl_certificate_validation = "False"
        ca_certs_path = ""

        proxy_enabled = False
        proxy_type = "http"
        proxy_url = ""
        proxy_port = ""
        proxy_rdns = False
        proxy_username = ""
        proxy_password = ""

        for k, v in conf_objs[-2].items():
            if "loglevel" in v:
                log_level = v["loglevel"]
            if "http_scheme" in v:
                http_scheme = v["http_scheme"]
            if "disable_ssl_certificate_validation" in v:
                disable_ssl_certificate_validation = v[
                    "disable_ssl_certificate_validation"
                ]
            if "ca_certs_path" in v:
                ca_certs_path = v["ca_certs_path"]
            if "proxy_enabled" in v:
                proxy_enabled = v["proxy_enabled"]
            if "proxy_type" in v:
                proxy_type = v["proxy_type"]
            if "proxy_url" in v:
                proxy_url = v["proxy_url"]
            if "proxy_port" in v:
                proxy_port = v["proxy_port"]
            if "proxy_username" in v:
                proxy_username = v["proxy_username"]
            if "proxy_password" in v:
                proxy_password = v["proxy_password"]
            if "proxy_rdns" in v:
                proxy_rdns = v["proxy_rdns"]

        for task_config in all_task_configs:
            task_config["log_level"] = log_level
            task_config["http_scheme"] = http_scheme
            task_config[
                "disable_ssl_certificate_validation"
            ] = disable_ssl_certificate_validation
            task_config["ca_certs_path"] = ca_certs_path
            task_config["proxy_enabled"] = proxy_enabled
            task_config["proxy_type"] = proxy_type
            task_config["proxy_url"] = proxy_url
            task_config["proxy_port"] = proxy_port
            task_config["proxy_username"] = proxy_username
            task_config["proxy_password"] = proxy_password
            task_config["proxy_rdns"] = proxy_rdns

        return all_task_configs

    def _extract(self, x):
        for item in x.split("|"):
            for y in item.split(","):
                y = y.strip()
                if ":" not in y:
                    y = self.metas["app_name"] + ":" + y

                yield y

    @staticmethod
    def _create_task_config(task, task_template, remote_server):
        """
        interval in task overrides interval in remote_server
        """

        template_name = task_template["appName"] + ":" + task_template["name"]
        task_config = {"task_template": template_name}
        task_config.update(task_template)
        task_config.update(remote_server)
        task_config.update(task)

        required_keys = (
            "account_name",
            "account_password",
            "server_url",
            "content",
            "index",
            "duration",
            "disabled",
        )
        msg = "Required key={} not in found"
        for k in required_keys:
            if k not in task_config:
                _LOGGER.error(msg.format(k))
                raise Exception(msg.format(k))
        return task_config

    def _get_task_templates_for_task(self, task, task_templates):
        templates = {}
        ns_templates = self._extract(task["templates"])
        for temp_name in ns_templates:
            if temp_name in task_templates:
                templates[temp_name] = task_templates[temp_name]
            else:
                msg = (
                    "{0} task template referenced in tasks conf, but not "
                    "defined or disabled in templates conf"
                ).format(temp_name)
                _LOGGER.error(msg)

        if not templates:
            msg = "No valid task templates found for task {0}".format(task["name"])
            _LOGGER.error(msg)

        return templates

    def _get_task_template_info_for_task(
        self, task, server_stanza, remote_server, task_templates
    ):
        task_configs = []
        templates = self._get_task_templates_for_task(task, task_templates)
        for name, template in templates.items():
            task_config = TAConfTask._create_task_config(task, template, remote_server)
            task_configs.append(task_config)
        return task_configs

    def _get_server_and_task_template_info_for_task(
        self, task, remote_servers, task_templates
    ):
        task_configs = []
        ns_servers = self._extract(task["servers"])
        for server_stanza in ns_servers:
            if server_stanza in remote_servers:
                remote_server = remote_servers[server_stanza]
                configs = self._get_task_template_info_for_task(
                    task, server_stanza, remote_server, task_templates
                )
                task_configs.extend(configs)
            else:
                msg = (
                    "{} server is referenced by tasks.conf, but it is "
                    "disabled or deleted in servers.conf."
                ).format(server_stanza)
                _LOGGER.error(msg)
        return task_configs

    @staticmethod
    def _get_conf_objects(ConfMgr, file_name):
        app_objs = []

        try:
            stanzas = ConfMgr.get_conf(
                "{}".format(file_name.replace(".conf", ""))
            ).get_all(only_current_app=True)
        except conf_manager.ConfManagerException:
            return {}

        for stanza, configs in stanzas.items():
            configs["name"] = stanza
            configs["appName"] = configs["eai:appName"]
            configs["_removable"] = configs["eai:access"].get("removable")

            if utils.is_true(configs.get("disabled")):
                continue
            app_objs.append(configs)

        return {obj["eai:appName"] + ":" + obj["name"]: obj for obj in app_objs}

    def _get_input_task_objects(self, inputs):
        input_objs = []

        for input_task, input_configs in inputs.items():
            input_configs["name"] = input_task
            input_configs["appName"] = self.metas["app_name"]
            input_objs.append(input_configs)

        return {obj["appName"] + ":" + obj["name"]: obj for obj in input_objs}
