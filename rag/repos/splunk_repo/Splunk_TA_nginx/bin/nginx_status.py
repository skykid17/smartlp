#
# SPDX-FileCopyrightText: 2024 Splunk, Inc.
# SPDX-License-Identifier: LicenseRef-Splunk-8-2021
#
#
# encoding = utf-8

import splunk_ta_nginx_import_declare  # noqa: F401 # isort:skip

import base64
import json
import logging
import os
import re
import sys
import traceback
from configparser import ConfigParser

import modinput_wrapper.base_modinput
import requests as rq
import splunk.rest as rest
import splunklib.client as client
import splunklib.modularinput as smi
from splunk.clilib.bundle_paths import make_splunkhome_path
from splunktalib.common import log, util

logger = log.Logs().get_logger("nginx_status")

"""
    This file is auto generated by Add-on Builder.
"""


class NginxStatusModinput(modinput_wrapper.base_modinput.SingleInstanceModInput):
    def __init__(self):
        super(NginxStatusModinput, self).__init__("TA_Nginx", "nginx_status")

    def get_scheme(self):
        """overloaded splunklib modularinput method"""
        scheme = smi.Scheme("nginx_status")
        scheme.title = "Splunk Add-on for Nginx"
        scheme.description = "NGINX Status API Input"
        scheme.use_external_validation = True
        scheme.streaming_mode_xml = True
        scheme.use_single_instance = False

        scheme.add_argument(
            smi.Argument(
                "name",
                title="Name",
                description="",
                required_on_create=True,
                required_on_edit=True,
            )
        )
        scheme.add_argument(
            smi.Argument(
                "host_name",
                title="Nginx URL",
                description="Location of the Nginx status JSON REST interface (e.g. 127.0.0.1/api)",
                required_on_create=True,
                required_on_edit=True,
            )
        )
        scheme.add_argument(
            smi.Argument(
                "loglevel",
                title="Log Level",
                description="",
                required_on_create=True,
                required_on_edit=True,
            )
        )
        scheme.add_argument(
            smi.Argument(
                "nginx_username",
                title="Nginx Username",
                description="Username to access the Nginx status JSON REST interface",
                required_on_create=False,
                required_on_edit=False,
            )
        )
        scheme.add_argument(
            smi.Argument(
                "nginx_pwd",
                title="Nginx Password",
                description="Password to access the Nginx status JSON REST interface",
                required_on_create=False,
                required_on_edit=False,
            )
        )
        scheme.add_argument(
            smi.Argument(
                "nginx_plus_types",
                title="Nginx Plus Type(s)",
                description=(
                    "Enter comma-separated Nginx Plus Types for which data needs "
                    "to be fetched. Allowed values are processes,connections,slabs,http,stream,resolvers,ssl"
                ),
                required_on_create=True,
                required_on_edit=True,
            )
        )

        return scheme

    def validate_input(self, definition):
        """
        overloaded splunklib modularinput method for input validation
        :param definition: contain input form data
        :return: None
        """
        nginx_host_name_pattern = re.compile(
            "^(http(s?)://)?([\w\-\.]+|(\[[0-9a-fA-F:]+\]))(:\d{1,5})?([\?|\/][\w\/\&\%\-\.\?\=]+)?$"  # noqa: W605
        )
        nginx_host_name_pattern_http_scheme_validation = re.compile(
            "^([\w\-\.]+|(\[[0-9a-fA-F:]+\]))(:\d{1,5})?([\?|\/][\w\/\&\%\-\.\?\=]+)?$"  # noqa: W605
        )
        log_level_values = ["debug", "info", "warning", "error"]
        loglevel = definition.parameters.get("loglevel", None)
        if not loglevel:
            logger.error("Log level can not be empty.")
            raise Exception("Log level can not be empty.")
        if loglevel.lower() not in log_level_values:
            logger.error(
                "Log level must be one of the following: %s",
                ", ".join(log_level_values),
            )
            raise Exception(
                "Log level must be one of the following: {}".format(
                    ", ".join(log_level_values)
                )
            )
        if not nginx_host_name_pattern.match(
            definition.parameters.get("host_name", "")
        ):
            logger.error("Invalid Nginx URL.")
            raise Exception("Invalid Nginx URL.")
        if not nginx_host_name_pattern_http_scheme_validation.match(
            definition.parameters.get("host_name", "")
        ):
            logger.error(
                "Enter URL without http_scheme (http or https) e.g. 127.0.0.1/api"
            )
            raise Exception(
                "Enter URL without http_scheme (http or https) e.g. 127.0.0.1/api"
            )
        self.validate_nginx_plus_types(definition.parameters.get("nginx_plus_types"))
        if definition.parameters.get("nginx_username", None) and (
            not definition.parameters.get("nginx_pwd", None)
        ):
            logger.error("Nginx Password is mandatory when Nginx Username is added.")
            raise Exception("Nginx Password is mandatory when Nginx Username is added.")
        if definition.parameters.get("nginx_pwd", None) and (
            not definition.parameters.get("nginx_username", None)
        ):
            logger.error("Nginx Username is mandatory when Nginx Password is added.")
            raise Exception("Nginx Username is mandatory when Nginx Password is added.")
        self.validate_credential(definition)

    def collect_events(self, inputs, ew):
        """
        overloaded splunklib modularinput method for event collection
        :param inputs: contain modular input data
        :param ew: use to ingest the events
        :return: None
        """
        # use simple rest call to load the events
        self.header = {}
        app_name = os.path.abspath(__file__).split(os.path.sep)[-3]
        session_key = self._input_definition.metadata["session_key"]
        input_name, input_items = inputs.inputs.popitem()
        output_index = input_items["index"]
        output_sourcetype = input_items["sourcetype"]
        nginx_username = input_items.get("nginx_username")
        nginx_pwd = input_items.get("nginx_pwd")
        url = input_items.get("host_name")

        loglevel = input_items["loglevel"]
        if loglevel.lower() == "debug":
            logger.setLevel(logging.DEBUG)
        elif loglevel.lower() == "info":
            logger.setLevel(logging.INFO)
        elif loglevel.lower() == "error":
            logger.setLevel(logger.ERROR)
        elif loglevel.lower() == "warning":
            logger.setLevel(logging.WARNING)

        try:
            nginx_plus_types = self.validate_nginx_plus_types(
                input_items.get("nginx_plus_types")
            )
            nginx_plus_types.append("nginx")
        except Exception:
            sys.exit()

        # Validate host format is valid, i.e. without http_scheme appended
        logger.debug("Validating format of NGINX Host")
        if re.search(":\/\/", url):  # noqa: W605
            logger.error(
                "The format of the NGINX host %s is invalid. To resume data collection, enter"
                " the host in configuration page"
                " of the Splunk Add-on for NGINX without http_scheme (http or https)",
                url,
            )
            sys.exit()
        logger.debug("Format of NGINX host %s, successfully validated", url)

        try:
            (
                url,
                self.enable_ssl_certificate_validation,
                self.ca_certs_path,
            ) = self.read_nginx_settings_conf_file(url)
        except Exception:
            sys.exit()

        if nginx_username and nginx_pwd:
            input_type, nginx_input = input_name.split("://")
            realm = app_name + "_" + nginx_input + "_" + nginx_username
            try:
                if nginx_pwd != "******":
                    self.encrypt_password(realm, nginx_pwd, session_key)
                    self.mask_password(session_key, input_name)
            except Exception as e:
                logger.error(
                    "There was an error when encrypting/masking the password " + str(e)
                )
            if self.get_password(session_key, realm):
                nginx_credentials = base64.urlsafe_b64encode(
                    (
                        nginx_username + ":" + self.get_password(session_key, realm)
                    ).encode("UTF-8")
                ).decode("ascii")
                self.header = {"Authorization": "Basic " + nginx_credentials}
            else:
                logger.error(
                    "Failed to get password of username:%s for input:%s.Reconfigure the username"
                    " and password and try again.",
                    nginx_username,
                    nginx_input,
                )
                sys.exit()

        input_items.pop("nginx_username")
        input_items.pop("nginx_pwd")
        input_items["nginx_plus_types"] = nginx_plus_types
        logger.debug(
            "Start to collect_events. Input name:%s, configuration:%s",
            input_name,
            input_items,
        )

        try:
            if self.enable_ssl_certificate_validation and not self.ca_certs_path:
                resp = rq.get(url, timeout=10, verify=True, headers=self.header)
            else:
                resp = rq.get(
                    url, timeout=10, verify=self.ca_certs_path, headers=self.header
                )
            resp.raise_for_status()
        except Exception as e:
            logger.error(
                "Error while getting version(s) using '%s' URL, error: %s, traceback: %s",
                url,
                str(e),
                traceback.format_exc(),
            )
            sys.exit()

        latest_nginx_api_version = json.loads(
            resp.content.decode("utf-8", errors="ignore")
        )[-1]
        latest_nginx_api_version_url = url + "/" + str(latest_nginx_api_version)
        nginx_api_event = self.get_nginx_api_data(
            latest_nginx_api_version_url, nginx_plus_types
        )
        if "nginx" not in list(nginx_api_event.keys()):
            logger.error(
                "Skipping event as 'nginx' (Nginx Plus Type) data is not available"
            )
            sys.exit()

        try:
            event = self.new_event(
                source=input_name,
                index=output_index,
                sourcetype=output_sourcetype,
                data=json.dumps(nginx_api_event),
            )
            ew.write_event(event)
        except Exception as e:
            logger.error(
                "Error while ingesting an event, error: %s, traceback: %s",
                str(e),
                traceback.format_exc(),
            )
            sys.exit()

    def encrypt_password(self, username, password, session_key):
        """
        encrypt password and store it into passwords.conf
        :param username: username to encrypt the password of
        :param password: password to be encrypted
        :param session_key: use for authentication
        :return: None
        """
        args = {"token": session_key}
        service = client.connect(**args)

        try:
            for storage_password in service.storage_passwords:
                if storage_password.username == username:
                    service.storage_passwords.delete(username=storage_password.username)
                    break

            service.storage_passwords.create(password, username)

        except Exception as e:
            logger.error(  # nosemgrep false-positive : This logger prints traceback of error
                # and User Creds. are not being exposed.
                "An error occurred updating credentials. Please ensure your user account has"
                " admin_all_objects and/or list_storage_passwords"
                " capabilities. Details: %s",
                traceback.format_exc(),
            )
            raise e

    def mask_password(self, session_key, input_name):
        """
        mask the password in inputs.conf
        :param session_key: use for authentication
        :param input_name: modular input name
        :return: None
        """

        try:
            input_type, nginx_input = input_name.split("://")

            kwargs = {
                "nginx_pwd": "******",
            }

            # Get call to fetch the app_name in which input is created
            resp, input_conf_data = rest.simpleRequest(
                "/servicesNS/nobody/-/configs/conf-inputs/",
                sessionKey=session_key,
                getargs={"output_mode": "json"},
                raiseAllErrors=True,
            )
            input_conf_data = json.loads(input_conf_data)
            for input_item in input_conf_data["entry"]:
                if input_item["name"] == input_name:
                    app_name = input_item["acl"]["app"]

            # Updating the inputs.conf to mask the password
            rest.simpleRequest(
                "/servicesNS/nobody/"
                + app_name
                + "/configs/conf-inputs/"
                + input_type
                + "%3A%2F%2F"
                + nginx_input
                + "?output_mode=json",
                session_key,
                postargs=kwargs,
                method="POST",
                raiseAllErrors=True,
            )

        except Exception as e:
            raise Exception("Error updating inputs.conf: {}".format(str(e)))

    def get_password(self, session_key, username):
        """
        get clear password of username
        :param session_key: use for authentication
        :param username: username to find password of
        :return: None
        """
        args = {"token": session_key}
        service = client.connect(**args)

        for storage_password in service.storage_passwords:
            if storage_password.username == username:
                return storage_password.content.clear_password

    def get_nginx_api_data(self, url, nginx_plus_types):
        """
        get event of each Nginx Plus Type
        :param url: url for getting event
        :param nginx_plus_types: Nginx Plus Types/Subtypes
        :return: dictinory of event
        """
        event_data = {}
        for nginx_plus_type in nginx_plus_types:
            nginx_plus_type_url = url + "/" + nginx_plus_type
            try:
                if self.enable_ssl_certificate_validation and not self.ca_certs_path:
                    resp = rq.get(
                        nginx_plus_type_url,
                        timeout=10,
                        verify=True,
                        headers=self.header,
                    )
                else:
                    resp = rq.get(
                        nginx_plus_type_url,
                        timeout=10,
                        verify=self.ca_certs_path,
                        headers=self.header,
                    )
                resp.raise_for_status()
            except rq.exceptions.HTTPError as e:
                logger.error(
                    "Encounter an error for '%s' URL, error: %s, traceback: %s",
                    nginx_plus_type_url,
                    str(e),
                    traceback.format_exc(),
                )
                continue
            except Exception as e:
                logger.error(
                    "Unable to connect to '%s' URL, error: %s, traceback: %s",
                    nginx_plus_type_url,
                    str(e),
                    traceback.format_exc(),
                )
                continue

            nginx_plus_type_data = json.loads(
                resp.content.decode("utf-8", errors="ignore")
            )

            if nginx_plus_type in ["http", "stream"]:
                data = self.get_nginx_api_data(
                    nginx_plus_type_url, nginx_plus_type_data
                )
                event_data[nginx_plus_type] = data
            else:
                event_data[nginx_plus_type] = nginx_plus_type_data

        return event_data

    def validate_nginx_plus_types(self, nginx_plus_types):
        """
        validation of Nginx Plus Types
        :param nginx_plus_types: contain nginx_plus_types
        :return: list of Nginx Plus Types
        """
        allowed_nginx_plus_types = [
            "processes",
            "connections",
            "slabs",
            "http",
            "stream",
            "resolvers",
            "ssl",
        ]
        nginx_plus_types = nginx_plus_types.split(",")
        nginx_plus_types = list(
            map(
                lambda nginx_plus_type: nginx_plus_type.strip().lower(),
                nginx_plus_types,
            )
        )
        nginx_plus_types = list(set(nginx_plus_types))

        if len(nginx_plus_types) > 7:
            logger.error(
                "Allowed Nginx Plus Types are 'processes,connections,slabs,http,stream,resolvers,ssl' only"
            )
            raise Exception(
                "Allowed Nginx Plus Types are 'processes,connections,slabs,http,stream,resolvers,ssl' only"
            )

        for each_nginx_plus_type in nginx_plus_types:
            if each_nginx_plus_type not in allowed_nginx_plus_types:
                logger.error("Found unknown Nginx Plus Type '%s'", each_nginx_plus_type)
                raise Exception(
                    "Found unknown Nginx Plus Type '{}'".format(each_nginx_plus_type)
                )

        return nginx_plus_types

    def validate_credential(self, definition):
        """
        credential validation for accessing nginx endpoint
        :param definition: contain input form data
        :return: None
        """
        url = definition.parameters.get("host_name")
        nginx_username = definition.parameters.get("nginx_username")
        nginx_pwd = definition.parameters.get("nginx_pwd")

        (
            url,
            enable_ssl_certificate_validation,
            ca_certs_path,
        ) = self.read_nginx_settings_conf_file(url)
        if nginx_username is None:
            nginx_username = ""
            nginx_pwd = ""

        nginx_credentials = base64.urlsafe_b64encode(
            (nginx_username + ":" + nginx_pwd).encode("UTF-8")
        ).decode("ascii")
        header = {"Authorization": "Basic " + nginx_credentials}

        try:
            if enable_ssl_certificate_validation and not ca_certs_path:
                resp = rq.get(url, timeout=10, verify=True, headers=header)
            else:
                resp = rq.get(url, timeout=10, verify=ca_certs_path, headers=header)
            resp.raise_for_status()
        except rq.exceptions.HTTPError as e:
            logger.error(
                "Encounter an error for '%s' URL, ERROR: %s, traceback: %s",
                url,
                str(e),
                traceback.format_exc(),
            )
            raise Exception(
                "Encounter an error for '{}' URL, ERROR: {}".format(url, str(e))
            )
        except Exception as e:
            logger.error(
                "Unable to connect to '%s' URL, ERROR: %s, traceback: %s",
                url,
                str(e),
                traceback.format_exc(),
            )
            raise Exception(
                "Unable to connect to '{}' URL, ERROR: {}".format(url, str(e))
            )

    def read_nginx_settings_conf_file(self, url):
        """
        Function to read configuration parameter from splunk_ta_nginx_settings.conf file
        :param url: user entered url
        :return: tuple of url, enable_ssl_certificate_validation, ca_certs_path
                 url: url to collect event
                 enable_ssl_certificate_validation: boolean
                 ca_certs_path: path of ca certificate
        """
        app_name = os.path.abspath(__file__).split(os.path.sep)[-3]
        app_path = make_splunkhome_path(["etc", "apps", app_name])
        parser = ConfigParser()
        conf_setting_file_path = os.path.join(
            app_path, "local", "splunk_ta_nginx_settings.conf"
        )
        parser.read(conf_setting_file_path)

        if "ssl_settings" not in parser.sections():
            conf_setting_file_path = os.path.join(
                app_path, "default", "splunk_ta_nginx_settings.conf"
            )
            parser.read(conf_setting_file_path)
            if "ssl_settings" not in parser.sections():
                logger.error(
                    "[ssl_settings] stanza not found in 'splunk_ta_nginx_settings.conf' file"
                )
                raise Exception(
                    "[ssl_settings] stanza not found in 'splunk_ta_nginx_settings.conf' file"
                )

        http_scheme = parser.get("ssl_settings", "http_scheme").lower()
        enable_ssl_certificate_validation = util.is_true(
            parser.get("ssl_settings", "enable_ssl_certificate_validation")
        )

        # Validate http_scheme is valid, i.e. http or https
        logger.debug(
            "Validating http_scheme parameter value from splunk_ta_nginx_settings.conf"
        )
        if http_scheme not in ["https", "http"]:
            logger.error(
                "While attempting to reach NGINX host, found incorrect http_scheme value %s, "
                "only possible values for http_scheme parameter are http or https. To resume data collection"
                ", enter the required http_scheme parameter (http or https) in "
                "splunk_ta_nginx_settings.conf file of Splunk Add-on for NGINX",
                http_scheme,
            )
            raise Exception(
                "While attempting to reach NGINX host, found incorrect http_scheme value {}, "
                "only possible values for http_scheme parameter are http or https. To resume data collection"
                ", enter the required http_scheme parameter (http or https) in "
                "splunk_ta_nginx_settings.conf file of Splunk Add-on for NGINX".format(
                    http_scheme
                )
            )

        logger.debug(
            "http_scheme parameter value %s, successfully validated", http_scheme
        )
        ca_certs_path = parser.get("ssl_settings", "ca_certs_path")

        if enable_ssl_certificate_validation is False:
            ca_certs_path = ""
        url = http_scheme + "://" + url

        return url, enable_ssl_certificate_validation, ca_certs_path


if __name__ == "__main__":
    exitcode = NginxStatusModinput().run(sys.argv)
    sys.exit(exitcode)
