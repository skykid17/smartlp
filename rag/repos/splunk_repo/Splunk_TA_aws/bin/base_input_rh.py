#
# SPDX-FileCopyrightText: 2021 Splunk, Inc. <sales@splunk.com>
# SPDX-License-Identifier: LicenseRef-Splunk-8-2021
#
#
from __future__ import absolute_import

import json
from urllib.parse import quote as urlquote

import aws_bootstrap_env  # noqa: F401 # pylint: disable=unused-import
import six
import splunk.admin as admin
import splunk_ta_aws.common.merge_util as merge_util
import splunk_ta_aws.common.ta_aws_consts as tac
import splunksdc.log as logging
from splunk_ta_aws.common.local_manager import LocalServiceManager
from splunklib import client as client
from splunktalib.common import util
from splunktaucclib.rest_handler.error import RestError

logger = logging.get_module_logger()
FIELDS = ["required_args", "opt_args", "group_fields", "input_name"]
IGNORE_FIELDS = [
    "host",
    "start_by_shell",
    "host_resolved",
    "eai:userName",
    "eai:appName",
    "python.version",
]


class BaseInputRestHandler(admin.MConfigHandler):
    """This is the base class for all one-to-many rest handlers, such as aws_cloudwatch, aws_config, and etc.

    By extending this class, simply implementing ```__init__``` function and set all params in ```FIELDS```
    """

    def __init__(self, *args, **kwargs):
        """
        Raises:
            NotImplementedError: in case there is any mandantory param that haven't been set
        """

        for arg in FIELDS:
            if not hasattr(self, arg):
                logger.error(
                    "Missing variable %s for handler. Please implement __init__ "  # pylint: disable=consider-using-f-string
                    "and set these variables to self: %s" % (arg, ", ".join(FIELDS))
                )
                raise NotImplementedError(
                    "Please implement __init__ and set these variables to self"
                )

        admin.MConfigHandler.__init__(self, *args, **kwargs)

        # Origin endpoint is generated by UCC and renamed by build.py
        # Refer to both build.py and restmap.conf
        if not hasattr(self, "_collection"):
            self._origin_endpoint = (
                getattr(self, "origin_endpoint")
                if hasattr(self, "origin_endpoint")
                else self.input_name + "_inputs_rh_ucc"
            )
            self._service = LocalServiceManager(
                app=tac.splunk_ta_aws, session_key=self.getSessionKey()
            ).get_local_service()
            self._collection = client.Collection(self._service, self._origin_endpoint)

    def setup(self):
        """Setup method for base input RH."""
        for arg in self.opt_args:
            self.supportedArgs.addOptArg(arg)

        for arg in self.required_args:
            self.supportedArgs.addReqArg(arg)

        return

    def handleList(self, confInfo):
        """List all inputs and merge them by common fields."""
        inputs = self._collection.list()

        logger.info(
            "%s: listing %d inputs in total" % (self.input_name, len(inputs))
        )  # pylint: disable=consider-using-f-string

        inputs_dict = merge_util.merge_inputs(
            self.input_name, inputs, self.group_fields
        )

        logger.info(
            "%s: merged into %d inputs" % (self.input_name, len(inputs_dict))
        )  # pylint: disable=consider-using-f-string

        for name, props in six.iteritems(inputs_dict):
            item = confInfo[name]
            for k, v in six.iteritems(props):
                # Each field in self.group_fields is a list.
                # Should be dumped into string before send back to client side.
                # Should we dump them here or inside merge_inputs?
                if k in self.group_fields:
                    item.append(k, json.dumps(v))
                elif k == "_conflict_fields":
                    item.append(k, json.dumps(v))
                else:
                    # Value of disabled needs to be True/False instead of 1/0 in UCC 5
                    if k == "disabled":
                        v = util.is_true(v)
                    item.append(k, v)

            item["eai:appName"] = tac.splunk_ta_aws
            item["eai:userName"] = "nobody"
            item.setMetadata(
                admin.EAI_ENTRY_ACL, {"owner": "nobody", "app": tac.splunk_ta_aws}
            )

        return

    def handleEdit(
        self, confInfo
    ):  # pylint: disable=invalid-name  # pylint: disable=unused-argument
        """Called when user invokes the "edit" action."""
        new_inputs_dict = self._get_inputs_from_req(self.callerArgs)
        (old_inputs_dict, inputs) = self._get_inputs_by_name(self.callerArgs.id)

        if len(new_inputs_dict) == 0 or len(old_inputs_dict) == 0:
            return

        creating_inputs = {}
        editing_inputs = []
        modified_keys = set()

        # Use the first item in new inputs and old inputs to check whether there is any common fields modification
        common_new_input = six.next(six.itervalues(new_inputs_dict))
        for key, value in six.iteritems(common_new_input):
            # Skip group fields
            if key in self.group_fields:
                continue

            for item in six.itervalues(old_inputs_dict):
                # Check if there is modification on this key
                if (key not in item) or (value != item[key]):
                    modified_keys.add(key)

        logger.info(
            "%s: the following common fields are modified (%s)"  # pylint: disable=consider-using-f-string
            % (self.input_name, modified_keys)
        )

        # In case of `{disabled: 1}`, there is no group fields.
        has_group_fields = True
        for key in self.group_fields:
            if key not in common_new_input:
                has_group_fields = False
                break

        logger.info(
            "has_group_fields = %s" % str(has_group_fields)
        )  # pylint: disable=consider-using-f-string

        if has_group_fields:
            # Iterate over all new inputs to figure out which inputs should be added
            for name, value in six.iteritems(new_inputs_dict):
                matched_input = self._find_input_by_value(value, old_inputs_dict)

                # If the new input exists in the old inputs, then it should be kept (pop from old_inputs_dict).
                # Any remaining inputs in old_inputs_dict will be removed
                #
                # If the new input does not exist, then put it to the creating_inputs
                if matched_input:
                    old_inputs_dict.pop(matched_input, None)
                    editing_inputs.append(matched_input)
                else:
                    creating_inputs[name] = value
        else:
            # No group field change -> No creating and removing -> Every inputs should be edited.
            editing_inputs = list(old_inputs_dict.keys())
            old_inputs_dict = {}

        creating_count = len(creating_inputs)
        edit_count = len(editing_inputs) if len(modified_keys) > 0 else 0
        removing_count = len(old_inputs_dict)
        logger.info(
            "%s: there are %s create, %s edit, and %s remove"  # pylint: disable=consider-using-f-string
            % (self.input_name, creating_count, edit_count, removing_count)
        )

        logger.debug(old_inputs_dict)
        logger.debug(editing_inputs)
        logger.debug(creating_inputs)
        disable_action = None
        for value in old_inputs_dict.values():
            disable_action = value.get("disabled", None)
            break

        # The order HAS to be Remove -> Edit -> Create
        self._remove_inputs(old_inputs_dict)
        self._edit_inputs(inputs, editing_inputs, common_new_input, modified_keys)
        self._create_inputs(creating_inputs, disable_action)
        return

    def handleCreate(self, confInfo):  # pylint: disable=unused-argument
        """Create inputs."""

        name = self.callerArgs.id
        (old_inputs, _) = self._get_inputs_by_name(name)

        if len(old_inputs) > 0:
            raise RestError(
                400, ' Name "%s" is already in use' % name
            )  # pylint: disable=consider-using-f-string

        inputs_dict = self._get_inputs_from_req(self.callerArgs)

        self._create_inputs(inputs_dict)

        return

    def handleRemove(self, confInfo):  # pylint: disable=unused-argument
        """Remove a group of inputs based on name"""
        logger.info(
            "%s: removing inputs (%s)" % (self.input_name, self.callerArgs.id)
        )  # pylint: disable=consider-using-f-string

        (inputs_dict, _) = self._get_inputs_by_name(self.callerArgs.id)
        self._remove_inputs(inputs_dict)
        return

    def _create_inputs(self, inputs_dict, disable_action=None):
        """Create inputs

        Args:
            inputs_dict (dict): The inputs to be created. The key of dict is the input name.

        Returns:

        """
        if len(inputs_dict) == 0:
            return

        for index, (name, value) in enumerate(six.iteritems(inputs_dict), 1):
            try:
                logger.info(
                    "%s: creating %s/%s input (%s)..."  # pylint: disable=consider-using-f-string
                    % (self.input_name, index, len(inputs_dict), name)
                )
                self._collection.create(name, **value)
                if disable_action is not None:
                    updated_dict = {"disabled": disable_action}
                    self._collection.update(name, **updated_dict)
            except Exception as err:  # noqa: F841
                logger.error(
                    "%s: error when creating input (%s). input dump (%s)"  # pylint: disable=consider-using-f-string
                    % (self.input_name, name, str(value))
                )

        # Add retry here.
        return

    def _remove_inputs(self, inputs_dict):
        """Remove inputs

        Args:
            inputs_dict (dict): The inputs to be removed. The key of dict is the input name.

        """
        if len(inputs_dict) == 0:
            return

        for index, (name, value) in enumerate(six.iteritems(inputs_dict), 1):
            try:
                logger.info(
                    "%s: removing %s/%s input (%s)..."  # pylint: disable=consider-using-f-string
                    % (self.input_name, index, len(inputs_dict), name)
                )
                self._collection.delete(urlquote(name))
            except Exception as err:  # noqa: F841
                logger.error(
                    "%s: error when removing input (%s). input dump (%s)"  # pylint: disable=consider-using-f-string
                    % (self.input_name, name, value)
                )

        # Add retry here.
        return

    def _edit_inputs(self, inputs, editing_inputs, input_template, modified_keys):
        """This method is used to update common fields for all inputs.

        Args:
            inputs (list): The list of input entities

            editing_inputs (list): The list of input names which will be edited

            input_template (dict): The template of new input which contains the updated value for each common fields

            modified_keys (list): List of keys which will be updated

        Returns:

        """
        if len(modified_keys) == 0 or len(editing_inputs) == 0 or len(inputs) == 0:
            return

        for index, (name) in enumerate(editing_inputs, 1):
            entity = next(x for x in inputs if x.name == name)

            updated_dict = merge_util.copy_content(self.input_name, entity)

            # This is a temp solution since those ignore fields should be added to spec
            for k in IGNORE_FIELDS:
                updated_dict.pop(k, None)

            for k in modified_keys:
                updated_dict[k] = input_template[k]

            # https://jira.splunk.com/browse/ADDON-12880
            # UCC handles `disabled` field separately.
            # If `disabled` field is provided, then other fields will be ignored.
            if "disabled" not in modified_keys:
                updated_dict.pop("disabled")

            try:
                logger.info(
                    "%s: editing %s/%s input (%s)..."  # pylint: disable=consider-using-f-string
                    % (self.input_name, index, len(editing_inputs), name)
                )
                is_entity_obj = isinstance(entity, client.Entity)
                if is_entity_obj:
                    entity.update(**updated_dict)
                else:
                    self._collection.update(
                        name, **updated_dict
                    )  # pylint: disable=no-member
            except Exception:  # noqa: F841
                logger.error(
                    "%s: error when editing input (%s). input dump (%s)"  # pylint: disable=consider-using-f-string
                    % (self.input_name, name, updated_dict)
                )

        return

    def _get_inputs_from_req(self, req):
        """Get the inputs from frontend request.
        The frontend side will always send one input. However, it will be separated into a few inputs
        based on the group fields.

        Args:
            req: The request (confInfo)

        Returns:
            (dict): The separated inputs dict

        """
        origin_input = {}

        for k in self.opt_args:
            if k in req:
                origin_input[k] = req[k][0]

        for k in self.required_args:
            if k in req:
                origin_input[k] = req[k][0]

        for k in origin_input:  # pylint: disable=consider-using-dict-items
            if origin_input[k] is None:
                origin_input[k] = ""

        inputs_dict = merge_util.separate_inputs(
            req.id, origin_input, self.group_fields
        )

        return inputs_dict

    def _get_inputs_by_name(self, name):
        """Get the inputs and entities based on input name.

        Args:
            name: The name of input

        Returns:
            (dict, list): The dict of inputs and the original input list (entities)

        """

        inputs = self._collection.list()

        logger.info(
            "%s: %d inputs in total. filtering by name (%s)..."  # pylint: disable=consider-using-f-string
            % (self.input_name, len(inputs), name)
        )

        inputs_dict = merge_util.match_inputs(self.input_name, inputs, name)

        logger.info(
            "%s: %d inputs after filtering."
            % (
                self.input_name,
                len(inputs_dict),
            )  # pylint: disable=consider-using-f-string
        )

        return (inputs_dict, inputs)

    def _find_input_by_value(self, value, inputs_dict):
        """Get the input from a list based on fields

        Returns:
            (string): The name of input
        """

        for name, input_value in six.iteritems(inputs_dict):
            matched = True
            for key in self.group_fields:
                if input_value.get(key, "") != value[key]:
                    matched = False
                    break

            if matched:
                return name

        return None
